- Define jobs.

  CREATE TABLE param_bindings
    - integer id
    - integer tasks_id
    - integer jobs_id
    - string name
    - string value
  CREATE TABLE tasks
    - integer id
    - string name
  CREATE TABLE jobs
    - integer id
    - integer next_id // increment and use for "anonymous" jobs
    - string name
    - integer tasks_id

  A job provides some context for task runs.  Specifically,
  - A directory (jobs/taskname/jobname).
  - Parameter bindings.  These are applied after all task parameters are
    resolved, but before user parameter bindings are specified.
  "runtask" always runs in a job's context.  If no job is specified, one
  is created implicitly.

- Add the ability to define a name for task outputs at any stage.  This would
  make it easy to reuse outputs for different tasks.  Plan:
  1. Any time any task as run, directly or not, record its outputs in the
     database.  Give the outputs name (some autoinc integer by default).
     (Should we record parameters?)
  2. Assign paths to outputs based on the name.  (Might need a "persist"
     property for outputs, this idea doesn't really make sense for transient
     outputs.  Or should all outputs be persistent, and VMs shouldn't be a
     possible output?)
  3. Add a new command line option, -i <task>:<input>=<name>.  When that
     is specified, the value of that input will come from the stored output.
     The child task will still be run, but most of the time it won't have
     anything to do.

  Example: I maintain a checkout of a certain branch and do some regular CI
  operations on it.  So, first I use the git/checkout task to create a named
  copy of the branch that I want, and refer to it in all tasks which compose
  the CI jobs.

  Syntax:

  $ bricoler runtask freebsd-src/build/vm-image@foo

  All tasks get an output named "foo".  Later I can run any of those tasks @foo
  and reuse outputs.  Or I can run a new task@foo which reuses some of those
  task outputs without having to rebuild.  Equivalent to -i <task>:<input>=foo
  for all tasks.

  Storage:

  In the workdir, create a store directory.  Under it will live a mirror of the
  task definition hierarchy.  Under each task's directory, there is one
  directory per output name.

- Make it possible for a task to provide auxiliary files.  foo.task's files
  would live in foo/.  The task context (i.e., "ctx" passed to Run()) would
  contain an absolute path to that directory, if it exists.

  This could be used to provide VM image overlays, test scripts, etc..

- Formalize the notion that inputs should not be modified.  This is necessary
  to promote reuse of inputs for CI purposes.
  - Audit all existing jobs for this.  e.g., vm-image modifies the stagedir.
